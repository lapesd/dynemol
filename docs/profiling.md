# Profiling

Description of the software profiling process.


## Why?

With the use of tools, such as `gprof`, it is much easier to find the places of code that need attention. Before, it would be needed to 'execute' the code by hand. A very tedious and time consuming task.


## gprof

As descbried in `gprof`'s the man [page](https://linux.die.net/man/1/gprof):

> `gprof` produces an execution profile of C, Pascal, or Fortran77 programs.

This program, combined with the compiler flags `-pg`, produces a very insightful summary of the execution of the program. It shows:
- Number of times that functions were called during runtime;
- Approximate time that these calls took to run;
- Invocation tree, showing which function called which and how many times;
  - Using other tools, it is possible to create diagrams from the invocation tree generated by `gprof`. See [gprof2dot](https://github.com/jrfonseca/gprof2dot) if interested.

See `gprof`'s man [page](https://linux.die.net/man/1/gprof) for more info.


### Using

1. Compile your program with the flag `-pg`;
    - On this project, just add the flag to the `IFORT` variable in the makefile;
2. Execute the program, at least once, for it to check everything;
3. Call `gprof a` to see the info it gathered.


### Results

Profile created by executing the code with all the OpenMP directives removed. See limitations section below for more info.

```bash
$ gprof a -b
Flat profile:

Each sample counts as 0.01 seconds.
  %   cumulative   self              self     total
 time   seconds   seconds    calls   s/call   s/call  name
 46.00      4.95     4.95    57024     0.00     0.00  overlap_builder_mp_pulay_overlap_
 29.74      8.15     3.20  3319036     0.00     0.00  multipole_routines_m_mp_multipoles2c_
  5.67      8.76     0.61      201     0.00     0.00  overlap_builder_mp_build_overlap_matrix_
  5.48      9.35     0.59                             __intel_avx_rep_memset
  2.32      9.60     0.25    57325     0.00     0.00  semi_empirical_parms_mp_basis_opt_parameters_
  1.95      9.81     0.21                             __powr8i4
...
...
...
# more info down here
```
With the above output, it is plain that two procedures take most of the running time of the application.

- `overlap_builder_mp_pulay_overlap_`
  - Located in the `Overlap_Builder` module, in [overlap_D.f](../dynemol/overlap_D.f);
- `multipole_routines_m_mp_multipoles2c_`
  - Located in the `Multipole_Routines` module, in [multip_routines.f](./dynemol/multip_routines.f).


### Limitations

According to this [paper](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.14.1554&rep=rep1&type=pdf), `gprof` assumes that each call of a procedure has constant time. Which means, it takes the total time spent in some procedure and divide it by how many times it was called. If the procedure does not vary much between calls, it is OK. If not, the results may not be accurate.

Unfortunately, `gprof`'s thread support is almost non-existent. Making it almost useless for profiling multi-threaded applications as it will only profile the main thread.

This next profile was created before knowing the above described limitations. All the OpenMP directives were left **in** the program.
```bash
$ gprof -b a gmon.out
Flat profile:

Each sample counts as 0.01 seconds.
  %   cumulative   self              self     total
 time   seconds   seconds    calls   s/call   s/call  name
 34.77      2.10     2.10    57024     0.00     0.00  overlap_builder_mp_pulay_overlap_
 28.97      3.85     1.75  3319036     0.00     0.00  multipole_routines_m_mp_multipoles2c_
 14.57      4.73     0.88                             __intel_avx_rep_memset
 11.59      5.43     0.70      201     0.00     0.00  overlap_builder_mp_build_overlap_matrix_
  2.81      5.60     0.17                             __powr8i4
  0.99      5.66     0.06                             __libm_exp_l9
...
...
...
# more info down here
```
Attention to the top of the list. The most time consuming procedure still is the `pulay_overlap`. But `multipoles2c` gained more time. This is (probably) because of the division of work between thread. `multipoles2c` does not have any OpenMP directives in it, while the `pulay_overlap` does.

The third and fourth procedures had a very significant increase in time consumption. This is, as before, probably because the time of the `pulay_overlap` got split between threads. Leaving a larger chunk of time to be consumed by the other procedures.


## Other tools

The following tools where tested to profile the software:
- `operf`: did not run;
- `callgrind`: did not give meaningful info;
- `vtune`: took a huge amount of time to run the software, about 15x, and it took almost an hour to generate a ~500mb dump that is hard to interpret.


## Conclusion

The focus needs to be set in the functions that `gprof` showed. First in the `Overlap_Builder` and then in the `multipoles2c`. Further test will probably need to be made using the old-school way. `CPU_TIME`.

## Disclaimer

All tests described above were executed in the following machine:
- Intel(R) Xeon(R) CPU E5-2640 v4 @ 2.40GHz
- 128 Gb RAM
- NVIDIA Tesla K40c
