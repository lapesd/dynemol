# Profiling

Description of the software profiling process.


## Why?

With the use of tools, such as gprof, it is much easier to find the places of code that need attention. Before, it would be needed to 'execute' the code by hand. A very tedious and time consuming task.

With gprof, this task was minimized to very few steps, leaving time for more productive work.


## gprof

As descbried in gprof's the man [page](https://linux.die.net/man/1/gprof):

> "gprof" produces an execution profile of C, Pascal, or Fortran77 programs.

This program, combined with the compiler flags `-pg`, produces a very insightful summary of the execution of the program. It shows:
- Number of times that functions were called during runtime;
- Approximate time that these calls took to run;
- Invocation tree, showing which function called which and how many times;
  - Using other tools, it is possible to create diagrams from the invocation tree generated by gprof. See [gprof2dot](https://github.com/jrfonseca/gprof2dot) if interested.

See gprof's man [page](https://linux.die.net/man/1/gprof) for more info.


### Using gprof

1. Compile your program with the flag `-pg`;
    - On this project, just add the flag to the `IFORT` variable in the makefile;
2. Execute the program, at least once, for it to check everything;
3. Call `gprof a` to see the info it gathered.


### Results

Two profiles were generated. One with the OMP directives, and one without.


#### Without OMP

```bash
$ gprof a -b
Flat profile:

Each sample counts as 0.01 seconds.
  %   cumulative   self              self     total
 time   seconds   seconds    calls   s/call   s/call  name
 46.00      4.95     4.95    57024     0.00     0.00  overlap_builder_mp_pulay_overlap_
 29.74      8.15     3.20  3319036     0.00     0.00  multipole_routines_m_mp_multipoles2c_
  5.67      8.76     0.61      201     0.00     0.00  overlap_builder_mp_build_overlap_matrix_
  5.48      9.35     0.59                             __intel_avx_rep_memset
  2.32      9.60     0.25    57325     0.00     0.00  semi_empirical_parms_mp_basis_opt_parameters_
  1.95      9.81     0.21                             __powr8i4
...
...
...
# more info down here
```
With the above output, it is plain that two procedures take most of the running time of the application.

- `overlap_builder_mp_pulay_overlap_`
  - Located in the `Overlap_Builder` module, in [overlap_D.f](../dynemol/overlap_D.f);
- `multipole_routines_m_mp_multipoles2c_`
  - Located in the `Multipole_Routines_m` module, in [multip_routines.f](./dynemol/multip_routines.f).


#### With OMP

NOTE: this profiling was created with the OMP directives. Only later it was discovered that gprof does not work properly with multi-threaded applications. **This makes this profiling useless**. As of now, the Intel's VTune application will be used for profiling.
```bash
$ gprof a -b
Flat profile:

Each sample counts as 0.01 seconds.
  %   cumulative   self              self     total
 time   seconds   seconds    calls   s/call   s/call  name
 31.59      2.47     2.47  3319036     0.00     0.00  multipole_routines_m_mp_multipoles2c_
 31.46      4.93     2.46    57024     0.00     0.00  overlap_builder_mp_pulay_overlap_
 17.77      6.32     1.39                             __intel_avx_rep_memset
 11.51      7.22     0.90      201     0.00     0.00  overlap_builder_mp_build_overlap_matrix_
  1.41      7.33     0.11                             __powr8i4
  1.15      7.42     0.09      100     0.00     0.03  dp_main_m_mp_build_dipole_matrix_
...
...
...
# more info down here
```


### Disclaimer

All tests described above were executed in the following machine:
- Intel(R) Xeon(R) CPU E5-2640 v4 @ 2.40GHz
- 128 Gb RAM
- NVIDIA Tesla K40c
